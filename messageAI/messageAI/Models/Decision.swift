//
//  Decision.swift
//  messageAI
//
//  AI-extracted decision model
//

import Foundation
import FirebaseFirestore

/// Decision extracted from conversation
/// Generated by AI to track key team decisions
struct Decision: Codable, Identifiable {
    let id: String
    let summary: String               // Brief description of what was decided
    let context: String               // Why this decision was made
    let participants: [String]        // Names of people involved
    let tags: [String]                // Categories like "technical", "product"
    let conversationId: String        // Source conversation
    let conversationName: String      // Display name of conversation
    let timestamp: Date               // When decision was made/extracted
    let createdBy: String             // "ai" or "user"

    /// Initialize from Cloud Function response
    init(
        id: String = UUID().uuidString,
        summary: String,
        context: String,
        participants: [String],
        tags: [String],
        conversationId: String,
        conversationName: String,
        timestamp: Date = Date(),
        createdBy: String = "ai"
    ) {
        self.id = id
        self.summary = summary
        self.context = context
        self.participants = participants
        self.tags = tags
        self.conversationId = conversationId
        self.conversationName = conversationName
        self.timestamp = timestamp
        self.createdBy = createdBy
    }

    /// Parse from Firestore document
    init?(document: [String: Any]) {
        guard let id = document["id"] as? String,
              let summary = document["summary"] as? String,
              let context = document["context"] as? String,
              let participants = document["participants"] as? [String],
              let tags = document["tags"] as? [String],
              let conversationId = document["conversationId"] as? String,
              let conversationName = document["conversationName"] as? String,
              let createdBy = document["createdBy"] as? String else {
            return nil
        }

        self.id = id
        self.summary = summary
        self.context = context
        self.participants = participants
        self.tags = tags
        self.conversationId = conversationId
        self.conversationName = conversationName
        self.createdBy = createdBy

        // Parse timestamp
        if let timestamp = document["timestamp"] as? Timestamp {
            self.timestamp = timestamp.dateValue()
        } else {
            self.timestamp = Date()
        }
    }

    /// Get formatted date for display
    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: timestamp)
    }

    /// Get relative date for display (e.g., "Today", "Yesterday")
    var relativeDate: String {
        let calendar = Calendar.current
        let now = Date()

        if calendar.isDateInToday(timestamp) {
            return "Today"
        } else if calendar.isDateInYesterday(timestamp) {
            return "Yesterday"
        } else if calendar.isDate(timestamp, equalTo: now, toGranularity: .weekOfYear) {
            return "This Week"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d, yyyy"
            return formatter.string(from: timestamp)
        }
    }

    /// Get tag badges as formatted string
    var tagBadges: String {
        tags.map { "#\($0)" }.joined(separator: " ")
    }
}
